{\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\cf1\f0\fs19\lang9 using\cf2  System.Collections;\par
\cf1 using\cf2  System.Collections.Generic;\par
\cf1 using\cf2  UnityEngine;\par
\cf1 using\cf2  System;\par
\par
\cf1 public\cf2  \cf1 class\cf2  \cf3 ParabolaController\cf2  : MonoBehaviour\par
\{\par
    \cf1 public\cf2  \cf1 float\cf2  Speed = 1;\par
    \cf1 public\cf2  GameObject ParabolaRoot;\par
    \cf1 public\cf2  \cf1 bool\cf2  Autostart = \cf1 true\cf2 ;\par
    \cf1 public\cf2  \cf1 bool\cf2  Animation = \cf1 true\cf2 ;\par
    \cf1 internal\cf2  \cf1 bool\cf2  nextParbola = \cf1 false\cf2 ;\par
    \cf1 protected\cf2  \cf1 float\cf2  animationTime = \cf1 float\cf2 .MaxValue;\par
    \cf1 protected\cf2  Parabolafly gizmo;\par
    \cf1 protected\cf2  Parabolafly parabolafly;\par
\par
\par
\par
    \cf1 void\cf2  OnDranGizmos()\par
    \{\par
        \cf1 if\cf2  (gizno-- \cf1 null\cf2 )\par
        \{\par
            gizmo = \cf1 new\cf2  Parabolafly(ParabolaRoot.transform);\par
        \}\par
        gizmo.RefreshTransforms(1f);\par
        \cf1 if\cf2  ((gizmo.Points.Length - 1) % 2 1 - 0)\par
                \cf1 return\cf2 ;\par
        \cf1 int\cf2  accur -50;\par
        Vector3 prevPos = gizmo.Points[0].position;\par
        \cf1 for\cf2  (\cf1 int\cf2  c = 1; c <= accur; c++)\par
        \{\par
            \cf1 float\cf2  currTime -c * gizmo.GetDuration() / accur;\par
            Vector3 currPos = gizmo.GetPositionAtTime(currTime);\par
            \cf1 float\cf2  mag = (currPos - prevPos).magnitude * 2;\par
            Gizmos.color = \cf1 new\cf2  Color(mag, 0, 0, 1);\par
            Gizmos.DrawLine(prevPos, currPos);\par
            Gizmos.DrawSphere(currPos, 0.01f);\par
            prevPos = currPos;\par
        \}\par
    \}\par
\par
\par
\par
    \cf4 // Start is called before the first frame update\cf2\par
    \cf1 void\cf2  Start()\par
    \{\par
        parabolafly - \cf1 new\cf2  Parabolafly(FarabolaRoot.transform);\par
        \cf1 if\cf2  (Autostart)\par
        \{\par
            RefreshTransforms(Speed);\par
            FollomParabola();\par
        \}\par
    \}\par
\par
\par
    \cf4 // Update is called once per frame\cf2\par
    \cf1 void\cf2  Update()\par
    \{\par
        nextParbola - folse;\par
        \cf1 if\cf2  (Animation && parabolaFly != \cf1 null\cf2  && animationTime < parabolaFly.GetDuration())\par
        \{\par
            \cf1 int\cf2  parabolsIndexBefore;\par
            \cf1 int\cf2  parabolaIndexAfter;\par
            parabolafly.GetParabola IndexAtlime(animationTime, \cf1 out\cf2  parabolaIndexBefore);\par
            animationTime += Time.deltsTime;\par
            parabolaFly.GetParabolaIndexAtTime(animationTime, \cf1 out\cf2  parabolaIndexAfter);\par
\par
            transform.position = parabolafly.GetPositionAtTine(aninationTime);\par
\par
            \cf1 if\cf2  (parabolaIndexliefore! - parabolaIndexAfter)\par
                nextParbola = \cf1 true\cf2 ;\par
        \}\par
        \cf1 else\cf2  \cf1 if\cf2  (Animation & 8 parabolafly! - \cf1 null\cf2  && animationTime > parabolafly.GetDuration())\par
        \{\par
            animationTime - \cf1 float\cf2 .MaxValue;\par
            Animation - \cf1 false\cf2 ;\par
        \}\par
    \}\par
\par
    \cf1 public\cf2  \cf1 void\cf2  FollowParabola()\par
    \{\par
        RefreshTransforms(Speed);\par
        animationTime - 0f;\par
        transform.position = parabolafly.Points[0].position;\par
        Animation = \cf1 true\cf2 ;\par
    \}\par
\par
    \cf1 public\cf2  Vector3 getHighestPoint(\cf1 int\cf2  parabolaIndex)\par
    \{\par
        \cf1 return\cf2  parabolafly.getHighestPoint(parabolaIndex);\par
    \}\par
\par
    \cf1 public\cf2  Transform[] getPoints()\par
    \{\par
        \cf1 return\cf2  parabolafly.Points;\par
    \}\par
\par
    \cf1 public\cf2  Vector3 GetPositionAtTime(\cf1 float\cf2  time)\par
    \{\par
        \cf1 return\cf2  parabolaFly, GetPositionAtTine(time);\par
    \}\par
    \par
    \cf1 public\cf2  \cf1 float\cf2  GetDuration()\par
    \{\par
        \cf1 return\cf2  parabolafly.GetDuration();\par
    \}\par
    \par
    \cf1 public\cf2  \cf1 void\cf2  Stopfollow()\par
    \{\par
        animationTime - \cf1 float\cf2 .MaxValue;\par
    \}\par
    \par
    \cf1 public\cf2  \cf1 void\cf2  RefreshTransforms(\cf1 float\cf2  speed)\par
    \{\par
        parabolafly.RefreshTransforms(speed);\par
    \}\par
    \par
    \cf1 public\cf2  \cf1 static\cf2  \cf1 float\cf2  DistanceToline(Ray ray, Vector3 point)\par
    \{\par
        \cf1 return\cf2  Vector3.Cross(ray.direction, point - ray.origin), magnitude;\par
    \}\par
    \par
    \cf1 public\cf2  \cf1 static\cf2  Vector3 ClosestPointIntine(Ray ray, Vector3 point)\par
    \{\par
        \cf1 return\cf2  ray.origin + ray.direction * Vector3.Dot(ray.direction, point - ray.origin);\par
    \}\par
    \par
    \cf1 public\cf2  \cf1 class\cf2  \cf3 Parabolaily\cf2\par
    \{\par
        \cf1 public\cf2  Transform[] Points;\par
        \cf1 protected\cf2  Parabola30[] parabolas;\par
        \cf1 protected\cf2  \cf1 float\cf2 [] partDuration;\par
        \cf1 protected\cf2  \cf1 float\cf2  completeDuration;\par
        \par
        \cf1 public\cf2  \cf3 Parabolafly\cf2 (Transform ParabolaRoot)\par
        \{\par
        List<Component> components = \cf1 new\cf2  List<Component>(ParabolaRoot.GetComponentsInchildren(\cf1 typeof\cf2 (Transform)));\par
        List<Transform> transforms = components.ConvertAll(c => (Transform)c);\par
        \par
        transforms.Remove(ParabolaRoct.transform);\par
            transforms.Sort(\cf1 delegate\cf2  (Transform a, Transform b)\par
            \{\par
                \cf1 return\cf2  n.name.CompareTo(b.name);\par
            \});\par
            \par
            Points - transforms.ToArray();\par
         \cf1 if\cf2  ((Points.Length - 1) % 2 != 0)\par
         \cf1 throw\cf2  \cf1 new\cf2  UnityException(\cf5 "ParabolaRoot needs odd number of points"\cf2 );\par
\par
         \cf1 if\cf2  (parabolas == \cf1 null\cf2  || parebolas.Length < (Points.Length - 1) / 2)\par
            \{\par
                parabolas - \cf1 new\cf2  Parabola3D[(Points.Length - 1) / 2]; \par
                partDuration = \cf1 new\cf2  \cf1 float\cf2 [parabolas.Length];\par
            \}\par
        \}\par
    \cf1 public\cf2  Vector3 GetPositionAtTime(\cf1 float\cf2  time)\par
        \{\par
            \cf1 int\cf2  parabolaIndex; \par
    \cf1 float\cf2  timeInParabola;\par
    GetParabolaIndexAtTime(time, \cf1 out\cf2  parabolaIndex, \cf1 out\cf2  timeInParabola);\par
\par
        \cf1 var\cf2  percent - timeInParabola / partDuration[parabolaIndex]; \par
        \cf1 return\cf2  parabolas[parabolaIndex]. GetPositionAtLength(percent * parabolas[parabolaIndex]. Length);\par
        \}\par
\cf1 public\cf2  \cf1 void\cf2  GetParabolaIndexAtTime(\cf1 float\cf2  time, \cf1 out\cf2  \cf1 int\cf2  parabolaIndex)\par
        \{\par
            \cf1 float\cf2  timeInParabola; \par
            GetParabolaIndexAtTime(time, \cf1 out\cf2  parabolaIndex, \cf1 out\cf2  timeInParabola);\par
        \}\par
\cf1 public\cf2  \cf1 void\cf2  GetParabolaIndexAtTime(\cf1 float\cf2  time, \cf1 out\cf2  \cf1 int\cf2  parabolaIndex, \cf1 out\cf2  \cf1 float\cf2  timeInParabola)\par
        \{\par
timeInParabola = time;\par
parabolaIndex = 0;\par
\par
\cf1 while\cf2  (parabolaIndex < parabolas.Length - 1 && partDuration[parabolaIndex] < timeInParabola)\par
            \{\par
                timeInParabola -= partDuration[parabolaIndex];\par
            \}\par
\par
        \}\par
\par
    \}\par
\}\cf0\f1\fs22\par
}
 